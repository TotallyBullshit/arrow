\documentclass[titlepage]{report}

\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyhdr}

%\usepackage{lastpage} % for the number of the last page in the document
%\usepackage{fancyhdr}

\begin{document}

\title{Arrow: Functional Composable R}
\author{Ryan Grannell}

\maketitle
\tableofcontents

\chapter{Introduction}


\chapter{Collections}

\paragraph{}
Collections are finite linear ordered sequences of values. They are the basic
data structure in Arrow, with roughly three-quarters of methods being defined on collections
There are three types of collection used by Arrow, which are usually treated interchangably.

\paragraph{}
Atomic vectors are flat sequences of homogenously typed values. These values may be logical (True, False, Na),
integers, doubles, complex numbers, characters (strings), and raw values (bytes). They cannot
be mixed - an atomic vector can't contain two types of value. R is unusual in that it doesn't have
lone numbers or strings - instead it has length-one collections of numbers or strings. Atomic and generic vectors are internally represented
as a doubly-linked list.

\paragraph{}
Lists (also known as generic vectors) are less restrictive than atomic vectors - the elements can have mixed
typed, and may themselves be lists - they are recursive data types. The downside
for this extra flexibility is that lists use more memory and are less performant than atomic vectors.

\paragraph{}
Pairlists (also known as dotted pair lists) are the least useful and rarest collections in R. They are poorly supported
by external functions, but are used internally by R for function parametre lists. Unlike lists, they can have empty
named arguments, which makes them useful for representing argument lists with optional arguments. They are internally
represented as singly-linked lists.

\section{Collection Comprehensions}

Collection comprehensions provide syntactic sugar for defining collections by providing the contraints
that each element must satisfy to be a member of the collection. These are a translation of set-builder
notation, which defines a set in terms of membership constraints. The comprehension

$$xList[x^{2},\ x\ \leftarrow\ 1..10,\ x\ \%\%\ 2 ==\ 0 ]$$

translates to \"the list of values x squared such that x is evenly
divisible by 2, for x in 1, 2, ..., 10\". The values $x$ in 1..10 are tested to check if they are
evenly divisible by 2. Finally, the values are squared, added to a list, and returned. An equivalent comprehension in set-builder notation is

$$\{x^{2} \mid x\ mod\ 2 = 0 \}$$

In the above comprehensions only one dummy variable - $x$ - is used. Multiple dummy variables can be assigned in one comprehension. If the final expression isn't a variable binding expression it is interpreted as
a predicate to select elements to include in the output. This expression doesn't have to be included. The
yield expression denotes what should be returned by the comprehension; in the above example the square
of each multiple of two is returned.

\section{Set \& Combinatorics Operations}

Set and combinatorial functions are useful utilies for iterating over
and summarising data. Some of the key functions are covered below.

\subsection{xProdSetOf}

The set product of two collections is defined as the set of all ordered pairs
of values drawn from each collections.

$$X \times Y = \{(x, y) \mid x\ \epsilon\ X\ ^\wedge\ y\ \epsilon\ Y \}$$

$$xList[list(x, y),\ x\ \leftarrow\ X,\ y\ \leftarrow\ Y]$$

Arrow's set product is a generalised version of the above function, which can
take the product of more or less than two collections. The set product is Arrow's
replacement for nested for-loops. A single loop is often used to iterate over a
list of values, and a double loop is used to iterate over pairs of values or
over 2d-arrays.

The following imperative program generates every pair of indices between one and ten.

\begin{verbatim}

	# imperative code

	pairs <- list()
	for (ith in 1:10) {
	    for (jth in 1:10) {
	        pairs <- c(pairs, list(ith, jth))
	    }
	}
\end{verbatim}

The same program in Arrow is

\begin{verbatim}

	# functional code

	pairs <- xProdSetOf...(1:10, 1:10)
\end{verbatim}

\subsection{xPowerSetOf}

xPowerSet of calculates the power set of a collection. The power set of a
collection is the set of each of its subsets.

\begin{verbatim}
	xPowerSetOf( list(1, 2) )
	list(list(), list(1), list(2), list(1, 2))
\end{verbatim}

\subsection{xPermute}

The function xPermute re-arranges collections according to a set of indices.

\begin{verbatim}

	xPermute...( c(1,3,2), list('a', 'b', 'c'), list(1, 2, 3) )
	list(list("a", "c", "b"), list(1, 3, 2))

\end{verbatim}

xPermute can be used to re-order tabular data using indices. Several functions that
generate these indices are discussed later.

\subsection{xIsMember}

The function xIsMember tests is a value is a member of a collection. For example,

\begin{verbatim}
	xIsMember('a', letters)
\end{verbatim}

tests if $a$ is in the set of letters. Most Arrow predicates have a negation. In
this case, xNotMember tests if a value is absent from a collection.

\begin{verbatim}
	xNotMember('a', letters)
\end{verbatim}

\subsection{xUniqueOf}

The function xUniqueOf removes duplicated elements from a collection. For example,

\begin{verbatim}
	xUniqueOf(c(letters, letters))
\end{verbatim}

returns the set of letters after removing duplicate letters.
A related function xDuplicatesOf removes the first occurence
of an element, and keeps the remaining duplicates.

\begin{verbatim}
	xDuplicatesOf...('a', 'b', 'b', 'b')
	c('b', 'b')
\end{verbatim}


\subsection{xTabulate}

Arrow doesn't use the factors to represent categorical data. Instead,
collections of observations can be tabulated using xTabulate. This
takes the data and compresses it down to a collection of observation-frequency pairs,
which is similar to how factors are represented.

\begin{verbatim}
	votes <- c('no', 'yes', 'yes', 'no', 'yes', 'no', 'no')
	xTabulate(votes)

	list(list("no", 4), list("yes", 3))
\end{verbatim}











\part{Functions}

\section{xSelect}

Select is one of the simplest higher-order functions.

\begin{verbatim}
	xSelect(is.integer, )
\end{verbatim}

\section{xMap}

Map is probably the most common higher-order function, because it has an obvio


\section{xFoldl}

Fold is an amazingly flexible function - almost all collection functions in arrow can be
written using fold in just a few lines. Fold takes



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
