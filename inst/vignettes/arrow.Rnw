\documentclass[titlepage]{report}

\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyhdr}

%\usepackage{lastpage} % for the number of the last page in the document
%\usepackage{fancyhdr}

\newlength\longest

\begin{document}

\title{Arrow: Functional Composable R}
\author{Ryan Grannell}

\maketitle
\tableofcontents

\chapter{Introduction}

\chapter{Collections}

\paragraph{}

The R language has a wealth of classes, including factors, data frames, matrices, lists, pairlists and vectors.
Arrow unifies the latter three under the abstraction of a \textit{collection}. Collections are finite linear
ordered sequences of values. Lists, pairlists and atomic vectors are supported because they are the most
fundemental data structures in R. Data frames and other classes are built on top of vectors and tend to
suffer from odd corner cases that hinder compositionality.

\paragraph{}
R functions can suffer from problems with genericity. For example, the function cumsum can work on both
lists and atomic vectors of numbers, but the function sum cannot sum a list of numbers.

\begin{verbatim}
    cumsum(list(1:10))
    55

    sum(list(1:10))
    Error in sum(list(1:10)) : invalid 'type' (list) of argument
\end{verbatim}

\paragraph{}
Arrow smooths out the differences between lists and other vectors; a list of numbers is always
treated the same as an atomic vector of numbers.

\section{Types of Collection}

Atomic vectors are flat sequences of homogenously-typed values. There are several subtypes
of vector - logical, integer, double, complex, character (string) and raw (bytes). They cannot
have mixed types - each vector can only hold one type of value. Each element of an atomic
vector is length one. R is unusual as a language in that it has no lone numbers or strings -
every number or string is a length-one vector. Atomic vectors are internally represented
as doubly-linked lists.

\paragraph{}
Lists (also known as generic vectors) are potentially nested sequences of heterogenously-typed values.
They are less restrictive than atomic vectors in that they can contain other collections, and
can have mixed-type values. The downside for this extra flexibility is that lists use more
memory and are less performant than atomic vectors. Table \ref{table:memusage} shows the
comparative memory usage for the same dataset represented as an integer vector, a list and a pairlist.
For large flat datasets, lists take about fourtheen times more memory than atomic vectors.
\begin{table}
\begin{tabular}{l|llllll}
	data type & 1 & $10^{2}$ & $10^{3}$ & $10^{4}$ & $10^{5}$\\
	\hline
	integer & 48 & 88 & 440 & 4040 & 400,040\\
	list & 96 & 648 & 5640 & 56,040 & 5,600,040\\
	pairlist & 104 & 1040 & 10,400 & 104,000 & 10,400,000\\
\end{tabular}

\caption{Memory usage of the sequence 1...n in bytes}
\label{table:memusage}

\end{table}





\paragraph{}
Pairlists (also known as dotted pair lists) are the least useful and rarest collections in R - the value
NULL aside. They are poorly supported by base functions, but are used internally by R for function parametre
lists. Unlike lists, they can have empty named arguments, which makes them useful for representing argument
lists with optional arguments. Internally pairlists are represented as singly-linked lists.

\section{Collection Comprehensions}

Collection comprehensions provide syntactic sugar for defining collections by providing the contraints
that each element must satisfy to be a member of the collection. These are a translation of set-builder
notation, which defines a set in terms of membership constraints. The comprehension

\begin{equation} \label{eq:comprehensions-squares}
xList[x^{2},\ x\ \leftarrow\ 1..10,\ x\ \%\%\ 2 ==\ 0 ]
\end{equation}

translates to \"the list of values x squared such that x is evenly
divisible by 2, for x in 1, 2, ..., 10\". The values $x$ in 1..10 are tested to check if they are
evenly divisible by 2. Finally, the values are squared, added to a list, and returned. An equivalent
comprehension in set-builder notation is

\begin{equation} \label{eq:setbuilder-squares}
\{x^{2} \mid x\ \epsilon\ \{1..10\} \land\ x\ mod\ 2\ =\ 0 \}
\end{equation}

Collection comprehensions are made of three elements - a yield expression, binding expressions, and a
predicate expression (optional).

\subsection{Binding Expressions}

Binding expressions determine what parametres are added to the yield and predicate expressions. They
have two parts; a symbol dictating what to bind, and a collection of values that binding may have. At
runtime

\begin{equation} \label{eq:comprehension-sum}
xList[\ x\ +\ y,\ x\ \leftarrow\ 1:10,\ y\ \leftarrow\ 1:10\ ]
\end{equation}

essentially gets transformed to

\begin{equation} \label{eq:comprehension-sum-tranformed}
xList[(x\ :\ y)\ :=\ x\ +\ y,\ 1:10,\ 1:10\ ]
\end{equation}

before feeding the yield expression each combination of values from the value part
of the binding expressions.

\subsection{The Yield \& Predicate Expressions}

The yield expression is a transformation that is applied to each eligable combination of values
drawn from the binding expressions. The predicate expression is the test for eligability.

\paragraph{}

\begin{equation} \label{eq:comprehension-letters}
xList[toupper(letters),\ letter\ \leftarrow\ letters]
\end{equation}

Program \ref{eq:comprehension-letters} demonstrates how a yield transformation is applied to each
letter from the set of letters, yielding an uppercase set of letters. The above comprehension is
essentially transformed to

\begin{equation} \label{eq:comprehension-letters-transformed}
xList[letter\ :=\ toupper(letters),\ letters,\ letter\ :=\ True]
\end{equation}

internally. When no predicate expression is provided it defaults to the predicate xTruth - a function
that is always true. A user can optionally provide a more selective membership test.

\begin{equation} \label{eq:comprehension-letters-pred}
xList[toupper(letters),\ letter\ \leftarrow\ letters,\ is.element(letter,\ letters[1:10])]
\end{equation}

\section{Collection Operations}

\chapter{Functions}

Functions are mathematical objects that relate each input to one fixed output.

Not all R or Arrow functions are mathematical functions. For example,
xOneOf takes a collection and returns a random value from the collection. Although
it associates each input (a collection) with an output (an element from the collection),
the output may differ for the same input. This means it is an impure (or non-referentially tranparent)
function.


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
